from abc import ABC, abstractmethod
from functools import singledispatchmethod
from typing import IO


# Простой и понятный способ
# Создаем интерфейс и обязуем его наследников иметь методы и выплевывать унифицированные значения.
class Iterator(ABC):

    @abstractmethod
    def has_next(self) -> bool:
        pass

    @abstractmethod
    def next_item(self) -> int:
        pass


# Другой ИЗВРАЩЕННЫЙ способ - перегруженные методы init прямо в интерфейсе, без абстракции, готовое решение.
# Затем - использование чего-то вроде шаблона State для переключения между разными реализациями итератора
# (Хотя со Стейтом можно и без перегрузки - НО чередой Ифов)
# С одной стороны это все выглядит размазанно, с другой - для добавления типов не нужно плодить новые интерфейсы
# В клиентском коде, Итератор предоставляет весь необходимый функционал. При необходимости наследовать и переписать.
# Достаточно добавить реализацию в общий интерфейс Итератора. Плохо это или хорошо - хз, но так тоже можно :)

class Iterator2:

    @singledispatchmethod
    def __init__(self, thing_to_iterate):
        pass

    @__init__.register(list)
    def _(self):
        self.type = 'ListState()'  # На самом деле тут какой-то объект, отвечающий имплементации конкретного поведения
        pass    # Дальше различия в логике делегируются Стейту

    @__init__.register(IO)
    def _(self):
        self.type = 'FileState()'     # Кроме этой строчки, здесь все то же самое
        pass                       # Скорее всего, тут и кроется дьявол, ведь этого "дальше" может сколько угодно...

    def has_next(self):
        self.type.has_next()

    def next_item(self):
        self.type.has_next()


# А можно и перегружать методы has_next и next_item, но тогда им придется каждый раз проверять, кого они там итерируют
